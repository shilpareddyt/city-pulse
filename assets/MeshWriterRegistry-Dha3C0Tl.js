import{e as x}from"./TechniqueType-CFPo0AVB.js";import{ee as M,mT as W,aE as D,gJ as be,gI as Ie,mU as S,mV as $e,mW as O,mX as A,jv as E,mY as te,mZ as se,m_ as re,jZ as de,jA as w,gE as z,m$ as ie,n0 as G,n1 as ze,n2 as ae,ae as k,n3 as Le,aA as Ae,a3 as De,s as Se}from"./index-DYh0j3Yd.js";import{b as F,l as V,d as j}from"./UpdateTracking2D-BAgZfWKo.js";import{r as ne}from"./rasterizingUtils-C02vX10a.js";import{o as fe,N as Ee,x as X,d as Y,O as ke,f as N,F as Q,y as H,m as J,l as pe,s as Re,a as U,b as Te,t as Be,p as _e,u as Ce,T as Fe,k as We,S as ge,c as Oe,g as Ge,h as Ve,i as je,r as Ze,j as qe,A as ye,n as Xe,P as B,q as Ye,v as Ne,w as Qe,z as He,B as Je,C as Ue,D as Ke,E as et,G as tt,H as st,I as rt,J as it,K as at,L as nt,M as ot,Q as ct,R as lt,U as ht,V as ut,W as mt,X as dt,Y as ft,Z as pt}from"./PieChartMeshWriter-DK661E0S.js";import{c as _t}from"./constants-BFLErLYb.js";import{c as gt}from"./libtess-DFmaAJv_.js";import{d as yt,l as oe}from"./featureConversionUtils-C2yiVfGX.js";import{e as Z}from"./OptimizedFeature-jLaWtbcE.js";import{n as ce,a as le,r as Pt}from"./Utils-7DZ-ofaD.js";import{s as xt}from"./AttributeStore-B_TGH1HD.js";function K(f){let{pixelDimensions:e,texelDimensions:t,baseSize:n,referenceSize:r,strokeWidth:s,sizeRatio:a}=f;if(e||(e=f.sprite.sdf?[0,0]:[f.sprite.width,f.sprite.height]),t||(t=f.sprite.sdf?[0,0]:e),f.patternHeight!=null){const o=f.patternHeight/e[1];e[1]*=o,e[0]*=o}n===-1&&(n=e[1]),n=M(n),r=M(r),s=M(s);const i=(f.sprite.sdfDecodeCoeff??1)*a;return{...f,pixelDimensions:e,texelDimensions:t,baseSize:n,referenceSize:r,strokeWidth:s,sdfDecodeCoeff:i}}const q=64,vt=64,Mt=2;let Pe=class extends fe{get vertexSpec(){return{createComputedParams:K,optionalAttributes:{zoomRange:U,value1Position2Value2:Re,lineLength:pe},attributes:{id:J,bitset:H,pos:Q,offset:N.marker,uv:ke.marker,animationPointerAndBaseSizeAndReferenceSize:Y,sizing:X,angle:Ee}}}_write(e,t){const n=this.evaluatedMeshParams.sprite,{textureBinding:r}=n;e.recordStart(this.instanceId,this.attributeLayout,r);const s=t.getDisplayId();if(this.shift&&t.geometryType==="esriGeometryPolyline")this._writeParticles(e,t);else if(this.evaluatedMeshParams.placement!=null)this._writePlacedMarkers(e,t);else if(t.geometryType==="esriGeometryPolygon"){const a=t.readCentroidForDisplay();if(!a)return;const[i,o]=a.coords;this._writeQuad(e,s,i,o)}else if(t.geometryType==="esriGeometryPoint"){const a=t.readXForDisplay(),i=t.readYForDisplay();this._writeQuad(e,s,a,i)}else{const a=t.readGeometryForDisplay();a&&a.forEachVertex((i,o)=>{this._writeQuad(e,s,i,o)})}e.recordEnd()}_writePlacedMarkers(e,t){const n=F.fromFeatureSetReaderCIM(t)?.clone();if(!n)return;const r=-1,s=Te.getPlacement(n,r,this.evaluatedMeshParams.placement,M(1),e.id,Be());if(!s)return;const a=t.getDisplayId();let i=s.next(),o=null;for(;i!=null;){const c=i.tx,l=-i.ty;if(Math.abs(c)>ne||Math.abs(l)>ne){i=s.next();continue}const p=-i.getAngle();e.recordBounds(c,l,q,vt),this.shift?o&&this._writeQuad(e,a,o[0],o[1],void 0,p):this._writeQuad(e,a,c,l,void 0,p),o=[c,l],i=s.next()}}_writeParticles(e,t){const n=t.getDisplayId(),r=t.readGeometryForDisplay();if(!r)return;const s=[];r.forEachVertex((l,p)=>{s.push([l,p])});const a=wt(s);let i=0;for(let l=1;l<s.length;l++){const p=s[l][0]-s[l-1][0],u=s[l][1]-s[l-1][1],h=Math.sqrt(p*p+u*u);i+=h}const o=l=>{for(const p of a){const{a:u,b:h}=p;this._writeQuad(e,n,u.position[0],u.position[1],[u.distance-l,h.position[0],h.position[1],h.distance-l],this.evaluatedMeshParams.angleToLine?Math.atan2(u.direction[1],u.direction[0]):0,i,!0)}},{placement:c}=this.evaluatedMeshParams;if(!c||"placementTemplate"in c||c.type==="CIMMarkerPlacementOnVertices"){let l;if(c&&c.type!=="CIMMarkerPlacementOnVertices")l=c.placementTemplate;else{l=[0];for(const u of a){const{a:h,b:d}=u,m=h.position[0]-d.position[0],_=h.position[1]-d.position[1],g=Math.sqrt(m*m+_*_);l.push(g)}}let p=-1*i;for(;p<(1+Mt/2)*i;)for(const u of l)p+=u,o(p)}else c.type==="CIMMarkerPlacementAtExtremities"?c.extremityPlacement===W.JustBegin?o(1):c.extremityPlacement===W.JustEnd?(o(i-1),o(-1)):c.extremityPlacement===W.Both&&(o(1),o(i-1)):c.type==="CIMMarkerPlacementOnLine"&&o(i/2)}_writeQuad(e,t,n,r,s,a=0,i=0,o=!1){const c=this.evaluatedMeshParams.sprite,{rect:l}=c,p=l.x+D,u=l.y+D,h=l.x+l.width-D,d=l.y+l.height-D,m=e.vertexCount();o||e.recordBounds(n,r,q,q);const _={texXmin:p,texYmin:u,texXmax:h,texYmax:d,value1Position2Value2:s,angle:a/_t,lineLength:i};for(let g=0;g<4;g++)this._writeVertex(e,t,n,r,_);e.indexEnsureSize(6),e.indexWrite(m),e.indexWrite(m+1),e.indexWrite(m+2),e.indexWrite(m+1),e.indexWrite(m+3),e.indexWrite(m+2)}};function wt(f){const e=[];let t=0;for(let n=1;n<f.length;n++){const r=f[n-1],s=f[n],a=s[0]-r[0],i=s[1]-r[1],o=Math.sqrt(a*a+i*i),c=a/o,l=i/o;e.push({a:{position:r,distance:t,direction:[c,l]},b:{position:s,distance:t+o,direction:[c,l]}}),t+=o}return e}let bt=class extends Pe{constructor(){super(...arguments),this.shift=!1}},It=class extends Pe{constructor(){super(...arguments),this.shift=!0}};class xe extends fe{_write(e,t,n){const r=n??F.fromFeatureSetReaderCIM(t);if(!r)return;const s=this.evaluatedMeshParams.sprite,{textureBinding:a}=s;e.recordStart(this.instanceId,this.attributeLayout,a);const i=t.getDisplayId();this._writePoly(e,i,r.asOptimized()),e.recordEnd()}}let $t=class extends xe{constructor(){super(...arguments),this.vertexSpec={createComputedParams:K,attributes:{id:J,bitset:H,pos:Q,offset:N.fill,tlbr:ge,animationPointerAndBaseSizeAndReferenceSize:Y,sizing:X},optionalAttributes:{zoomRange:U,value1Position2Value2:_e,lineLength:Ze}}}_writePoly(e,t,n){const r=[];if(!qe(r,n))return;const s=e.vertexCount();n.forEachVertex((a,i)=>{this._writeVertex(e,t,a,i)}),e.indexEnsureSize(r.length);for(const a of r)e.indexWrite(s+a)}},zt=class{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0,this.pathLength=0}};const he=65535;class Lt extends xe{constructor(){super(...arguments),this.vertexSpec={createComputedParams:K,attributes:{id:J,bitset:H,pos:Q,offset:N.line,tlbr:ge,animationPointerAndBaseSizeAndReferenceSize:Y,sizing:X,accumulatedDistance:We,normal:Fe,segmentDirection:Ce},optionalAttributes:{zoomRange:U,value1Position2Value2:_e,lineLength:pe}},this._tessParams=new Oe,this._currentWrite=new zt,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:he,textured:!1},this._lineLength=0,this._lineTessellator=new gt((e,t,n,r,s,a,i,o,c,l,p)=>this._writeTesselatedVertex(e,t,n,r,s,a,i,o,c,l,p,this._lineLength),this._writeTriangle.bind(this),!1)}_writePoly(e,t,n){const a=Ge(F.fromOptimized(n,"esriGeometryPolyline"),64);if(a==null)return;const{_currentWrite:i,_tessellationOptions:o}=this,{baseSize:c,capType:l,joinType:p,miterLimit:u}=this.evaluatedMeshParams,h=M(.5*c);o.halfWidth=h,o.capType=Ve(l||be.Round),o.joinType=je(p||Ie.Round),o.miterLimit=u||2,i.out=e,i.id=t,i.vertexCount=0,i.indexCount=0,i.vertexFrom=e.vertexCount(),i.vertexBounds=1;for(const{line:d,start:m,pathLength:_}of a){o.initialDistance=m%he,i.pathLength=_,this._lineLength=0;for(let g=1;g<d.length;g++){const y=d[g].x-d[g-1].x,v=d[g].y-d[g-1].y;this._lineLength+=Math.sqrt(y*y+v*v)}this._lineTessellator.tessellate(d,o,!1)}}_writeTesselatedVertex(e,t,n,r,s,a,i,o,c,l,p,u){const{out:h,id:d,vertexBounds:m,pathLength:_}=this._currentWrite;return this.hasEffects&&h.recordBounds(e,t,m,m),this._tessParams.extrusionOffsetX=i,this._tessParams.extrusionOffsetY=o,this._tessParams.normalX=c,this._tessParams.normalY=l,this._tessParams.directionX=s,this._tessParams.directionY=a,this._tessParams.distance=p,this._tessParams.pathLength=_,this._tessParams.lineLength=u,this._writeVertex(h,d,e,t,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(e,t,n){const{out:r}=this._currentWrite;r.indexEnsureSize(3),r.indexWrite(e),r.indexWrite(t),r.indexWrite(n),this._currentWrite.indexCount+=3}}const R=1,L=0,At=128;function Dt(f,e,t){return de(`${f}${e}${t}`)}function St(f,e,t,n,r){return de(`${f}${r}${e}${t*2**(B-n)}`)}const Et=$e(f=>{let e=0;if(f===0)return 1/0;for(;!(f%2);)e++,f/=2;return e});class kt extends ye{constructor(){super(...arguments),this._zoomLevel=0}_write(e,t,n,r){if(this._zoomLevel=r||0,n!=null)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(t.geometryType){case"esriGeometryPoint":{const s=t.readXForDisplay(),a=t.readYForDisplay();this._writePoint(e,s,a,0,t);break}case"esriGeometryEnvelope":case"esriGeometryPolygon":{const s=t.readCentroidForDisplay();if(!s)return;const[a,i]=s.coords;this._writePoint(e,a,i,0,t);break}case"esriGeometryMultipoint":{let s=0;const a=F.fromFeatureSetReader(t);if(a?.nextPath())for(;a.nextPoint();)this._writePoint(e,a.x,a.y,s++,t);break}case"esriGeometryPolyline":this._writeLines(e,t)}}_getMetricDir(){const{horizontalAlignment:e,verticalAlignment:t}=this.evaluatedMeshParams;return[e==="center"?0:e==="right"?-1:1,t==="middle"?0:t==="bottom"?-1:1]}_createLineLabelMetric(e,t,n,r,s){const[a,i]=this._getMetricDir(),o=this.evaluatedMeshParams.scaleInfo?.maxScale??0,c=this.evaluatedMeshParams.scaleInfo?.minScale??0,l=this.evaluatedMeshParams.labelClassId;return new ce(e,l,t,n,r,a,i,o,c,s)}_writePoint(e,t,n,r,s){if(t<0||t>S||n<0||n>S)return;const a=this._getShaping();if(!a)return;const i=s.getDisplayId(),o=this.evaluatedMeshParams.labelClassId,c=Dt(s.getObjectId(),o,r),[l,p]=this._getMetricDir(),u=this.evaluatedMeshParams.scaleInfo?.maxScale??0,h=this.evaluatedMeshParams.scaleInfo?.minScale??0,d=this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0};e.metricStart(new ce(i,o,c,t,n,l,p,u,h,d)),this._writeGlyphs(e,i,t,n,a,0,d,void 0,!1),e.metricBoxWrite(a.boundsT),e.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const e of this._references){const t=e.getBoundsInfo();if(t)return t}return null}_writeLines(e,t){const{scaleInfo:n,verticalAlignment:r}=this.evaluatedMeshParams,s=this.evaluatedMeshParams.repeatLabelDistance||128,a=this._getShaping("middle");if(!a)return;const i=(c,l,p,u)=>this._placeSubdivGlyphs(c,l,p,u),o=(a.bounds.width+s)/(1<<R);this._current={out:e,id:t.getDisplayId(),objId:t.getObjectId(),shaping:a,zoomRange:Xe(n,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0},offsetDirection:null,pathIndex:0},this._verticalPlacement=r==="bottom"?"above":r==="top"?"below":null,this._verticalPlacement?this._writeAboveAndBelowAlong(t,i,o):this._writeCenterAlong(t,i,o)}_writeAboveAndBelowAlong(e,t,n){const{repeatLabel:r}=this.evaluatedMeshParams,{shaping:s}=this._current,a=s.bounds.halfHeight,i=e.readGeometryForDisplay();if(!i)return;const o=new Z;yt(o,i,!1,!1,"esriGeometryPolyline",1);const c=ue(new Z,o,a),l=ue(new Z,o,-a),p=oe(l,"esriGeometryPolyline",!1,!1),u=oe(c,"esriGeometryPolyline",!1,!1),h=V(u.paths,s.bounds.width),d=V(p.paths,s.bounds.width);this._current.offsetDirection="above";for(let m=0;m<h.length;m++)this._current.pathIndex=m,j(h[m],n,t,!!r);this._current.offsetDirection="below";for(let m=0;m<d.length;m++)this._current.pathIndex=m,j(d[m],n,t,!!r)}_writeCenterAlong(e,t,n){const{repeatLabel:r}=this.evaluatedMeshParams,{shaping:s}=this._current,a=V(e.readLegacyGeometryForDisplay().paths,s.bounds.width);for(let i=0;i<a.length;i++)this._current.pathIndex=i,j(a[i],n,t,!!r)}_placeSubdivGlyphs(e,t,n,r){const{allowOverrun:s,labelPosition:a,repeatLabelDistance:i}=this.evaluatedMeshParams,o=this._current.zoomRange[0],c=Et(t),l=this._current.shaping.bounds.width/(1<<R),p=Math.sqrt(i||At)/(1<<R),u=Math.min(n,r-n),h=this._current.shaping.isMultiline?B:Math.log2(u/(p+l/2)),d=t===0?h:Math.min(c,h),m=Math.max(o,this._zoomLevel+R-d),_=this._zoomLevel-m,g=this._current.shaping.bounds.width/2*2**_,y=St(this._current.objId,this._current.pathIndex,t,this._zoomLevel,this.evaluatedMeshParams.labelClassId);this._current.shaping.isMultiline?t===0&&this._placeStraight(e,m,y):s&&_<0?this._placeStraightAlong(e,o,y):a==="parallel"?this._placeStraightAlong(e,m,y):a==="curved"&&this._placeCurved(e,m,g,y)}_placeStraight(e,t,n){const{out:r,id:s,shaping:a,referenceBounds:i}=this._current,{x:o,y:c}=e;r.metricStart(this._createLineLabelMetric(s,n,o,c)),r.metricBoxWrite(a.boundsT);const l=e.angle*(180/Math.PI)%360,p=(e.angle*(180/Math.PI)+180)%360,u={clipAngle:l,mapAligned:!0,isLineLabel:!0,minZoom:t};this._writeGlyphs(r,s,o,c,a,0,i,u,!1);const h={clipAngle:p,mapAligned:!0,isLineLabel:!0,minZoom:t};this._writeGlyphs(r,s,o,c,a,0,i,h,!1),r.metricEnd()}_placeCurved(e,t,n,r){const{out:s,id:a}=this._current;s.metricStart(this._createLineLabelMetric(a,r,e.x,e.y));const i=e.clone(),o=e.angle*(180/Math.PI)%360,c=(e.angle*(180/Math.PI)+180)%360;this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||(this._placeFirst(i,t,1,o),this._placeBack(e,i,t,n,1,o),this._placeForward(e,i,t,n,1,o)),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||(this._placeFirst(i,t,0,c),this._placeBack(e,i,t,n,0,c),this._placeForward(e,i,t,n,0,c)),s.metricEnd()}_placeStraightAlong(e,t,n){const{out:r,id:s,shaping:a,zoomRange:i,referenceBounds:o}=this._current,{boxBorderLineColor:c,boxBackgroundColor:l}=this.evaluatedMeshParams,p=e.clone(),u=e.angle*(180/Math.PI)%360,h=(e.angle*(180/Math.PI)+180)%360,d=a.glyphs.length>0&&!(!c&&!l);if(r.metricStart(this._createLineLabelMetric(s,n,e.x,e.y)),d){const m=Math.max(t,i[0],0),_=Math.min(B,i[1]),g=O(A(),-e.angle),y={minZoom:m,maxZoom:_,clipAngle:u,mapAligned:!0,isLineLabel:!0},v=M(this.evaluatedMeshParams.offsetX),P=M(this.evaluatedMeshParams.offsetY);if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const b=E(v,-1*P),[I,$]=a.shapeBackground(te(A(),g,b));r.recordStart(this.instanceId,this.attributeLayout,a.glyphs[0].textureBinding),this._writeTextBox(r,s,e.x,e.y,$,o,y),r.recordEnd()}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const b=E(v,P),[I,$]=a.shapeBackground(te(A(),g,b));y.clipAngle=h,r.recordStart(this.instanceId,this.attributeLayout,a.glyphs[0].textureBinding),this._writeTextBox(r,s,e.x,e.y,$,o,y),r.recordEnd()}}this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||this._placeFirst(p,t,1,u,!0),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||this._placeFirst(p,t,0,h,!0),r.metricEnd()}_placeBack(e,t,n,r,s,a){const i=e.clone();let o=e.backwardLength+L;for(;i.prev()&&!(o>=r);)this._placeOnSegment(i,t,o,n,-1,s,a),o+=i.length+L}_placeForward(e,t,n,r,s,a){const i=e.clone();let o=e.remainingLength+L;for(;i.next()&&!(o>=r);)this._placeOnSegment(i,t,o,n,1,s,a),o+=i.length+L}_placeFirst(e,t,n,r,s=!1){const{out:a,id:i,shaping:o,zoomRange:c,referenceBounds:l}=this._current,p=o.glyphs,u=M(this.evaluatedMeshParams.offsetX),h=M(this.evaluatedMeshParams.offsetY),d=E(u,h),m=O(A(),-e.angle);se(d,d,m);for(const _ of p){const g=_.x>o.bounds.x?n:1-n,y=g*e.remainingLength+(1-g)*e.backwardLength,v=Math.abs(_.x+_.width/2-o.bounds.x),P=Math.max(0,this._zoomLevel+Math.log2(v/(y+L))),b=Math.max(t,s?0:P);if(_.maxZoom=Math.min(c[1],B),_.angle=e.angle+(1-n)*Math.PI,_.minZoom=Math.max(c[0],b),this._writeLineGlyph(a,i,e.x,e.y,_,r,l,!0),(n||this._current.offsetDirection)&&this._isVisible(_.minZoom,_.maxZoom)){const I=new le(_.bounds.x+d[0],_.bounds.y+d[1],_.bounds.width,_.bounds.height);a.metricBoxWrite(I)}}}_placeOnSegment(e,t,n,r,s,a,i){const{out:o,id:c,shaping:l,referenceBounds:p}=this._current,u=l.glyphs,h=e.dx/e.length,d=e.dy/e.length,m={x:e.x+n*-s*h,y:e.y+n*-s*d},_=M(this.evaluatedMeshParams.offsetX),g=M(this.evaluatedMeshParams.offsetY),y=E(_,g),v=O(A(),-e.angle);se(y,y,v);for(const P of u){const b=P.x>l.bounds.x?a:1-a;if(!(b&&s===1||!b&&s===-1))continue;const I=Math.abs(P.x+P.width/2-l.bounds.x),$=Math.max(0,this._zoomLevel+Math.log2(I/n)-.1),Me=Math.max(r,this._zoomLevel+Math.log2(I/(n+e.length+L)));if($!==0&&(P.angle=e.angle+(1-a)*Math.PI,P.minZoom=Me,P.maxZoom=$,this._writeLineGlyph(o,c,m.x,m.y,P,i,p,!0),(a||this._current.offsetDirection)&&this._isVisible(P.minZoom,P.maxZoom))){const we=new le(P.bounds.x+y[0],P.bounds.y+y[1],P.bounds.width,P.bounds.height);o.metricBoxWrite(we)}}}_writeLineGlyph(e,t,n,r,s,a,i,o){if(n<0||n>S||r<0||r>S)return;e.recordStart(this.instanceId,this.attributeLayout,s.textureBinding);const{texcoords:c,offsets:l}=s,{fontSize:p,haloSize:u,outlineSize:h}=this._textMeshTransformProps;this._writeQuad(e,t,n,r,{texcoords:c,offsets:l,fontSize:p,haloSize:u,outlineSize:h,color:Ye(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:i,minZoom:Math.max(this._current.zoomRange[0],s.minZoom),maxZoom:Math.min(this._current.zoomRange[1],s.maxZoom),clipAngle:a,mapAligned:o,isLineLabel:!0}),e.recordEnd()}_packedZoom(e){return Math.floor(e*re)/re}_isVisible(e,t){let n=Math.max(this._current.zoomRange[0],e),r=Math.min(this._current.zoomRange[1],t);n=this._packedZoom(n),r=this._packedZoom(r);const s=this._packedZoom(this._zoomLevel);return n<=s&&s<=r}}function ue(f,e,t){const{coords:n,lengths:r}=e,s=z(),a=z(),i=z(),o=z(),c=z(),l=z(),p=2;let u=0;for(let h=0;h<r.length;h++){const d=r[h];for(let m=0;m<d;m++){const _=p*(m+u-1),g=p*(m+u),y=p*(m+u+1);m>0?w(s,n[_],n[_+1]):w(s,0,0),w(a,n[g],n[g+1]),m<d-1?w(i,n[y],n[y+1]):w(i,0,0),m===0?w(o,0,0):(ie(o,a,s),G(o,o),w(o,o[1],-o[0])),m===d-1?w(c,0,0):(ie(c,i,a),G(c,c),w(c,c[1],-c[0])),ze(l,o,c),G(l,l);const v=l[0]*c[0]+l[1]*c[1];v!==0&&ae(l,l,v),ae(l,l,t),f.coords.push(a[0]+l[0],a[1]+l[1])}f.lengths.push(d),u+=d}return f}class Rt extends xt{constructor(e){super(),this._value=e}resize(e){}read(e,t){return this._value}readWithDefault(e,t,n){return this._value}hasArcadeDependency(e){return!1}}const Tt=()=>De.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator");async function T(f,e,t,n){const{defaultValue:r,valueExpressionInfo:s,value:a}=e;if(s){if(s.type==="dictionary-template")return{...e,computed:f.createDictionaryTemplateField(s,t),defaultValue:r};const{expression:i}=s,o=await f.createComputedField({expression:i},n);return o?{...e,computed:o,defaultValue:r}:null}return{...e,computed:new Rt(a),defaultValue:r}}async function me(f,e,t){const{valueExpressionInfo:n}=e,r=n.type==="dictionary-template"?f.createDictionaryTemplateField(n,t):await f.createComputedField({expression:n.expression});return r?{...e,computed:r}:null}function ve(f){return typeof f=="object"&&f!=null&&(!(!("valueExpressionInfo"in f)||!f.valueExpressionInfo)||"type"in f&&f.type==="Process"&&"op"in f&&f.op==="Random")}function C(f){if(Array.isArray(f)){for(const e of f)if(C(e))return!0}if(typeof f=="object"){if(ve(f))return!0;for(const e in f)if(C(f[e]))return!0}return!1}class ee{static async create(e,t,n,r){const s={},a=new Map,i=new Map,o=new Map,c=new Map,l=new Map,p=new Map;for(const u in n){const h=n[u];if(h!=null&&typeof h=="object")if(Array.isArray(h)){if(typeof h[0]=="object")throw new Error(`InternalError: Cannot handle ${u}. Nested array params are not supported`);s[u]=h}else if("valueExpressionInfo"in h){if(h.value){s[u]=h.value;continue}const d=await me(e,h,r);if(!d){s[u]=h.defaultValue;continue}a.set(u,d),s[u]=null}else switch(h.type){case"cim-effect-infos":if(h.effectInfos.some(d=>d.overrides.length)){i.set(u,{effects:await Promise.all(h.effectInfos.map(async d=>{const m=d.overrides.map(_=>T(e,_,r,!1));return{effect:d.effect,compiledOverrides:(await Promise.all(m)).filter(k)}}))});break}s[u]=h.effectInfos.map(d=>d.effect);break;case"cim-marker-placement-param":h.overrides.length&&o.set(u,{placementInfo:h,compiledOverrides:(await Promise.all(h.overrides.map(d=>T(e,d,r,!1)))).filter(k)}),s[u]=h.placement;break;case"text-rasterization-param":{if(h.overrides.length){const m=h.overrides.map(_=>T(e,_,r,h.useLegacyLabelEvaluationRules??!1));c.set(u,{compiledOverrides:(await Promise.all(m)).filter(k),rasterizationParam:h,objectIdToResourceId:new Map});continue}const d={type:"cim-rasterization-info",resource:h.resource};s[u]=await t.fetchResourceImmediate(d)??null;break}case"sprite-rasterization-param":{if(h.overrides.length){const m=h.overrides.map(_=>T(e,_,r,!1));c.set(u,{compiledOverrides:(await Promise.all(m)).filter(k),rasterizationParam:h,objectIdToResourceId:new Map});continue}if(h.resource.type==="animated"){c.set(u,{compiledOverrides:[],rasterizationParam:h,objectIdToResourceId:new Map});continue}const d={type:"cim-rasterization-info",resource:h.resource};s[u]=await t.fetchResourceImmediate(d)??null;break}case"cim-marker-transform-param":{const{params:d}=h;if(C(d)){const m={compiledMarkerInfos:[]};await Promise.all(d.map(async _=>{const g={props:{}};for(const y in _)if(ve(_[y])){const v=await me(e,_[y],r);g.compiledExpressionMap||(g.compiledExpressionMap=new Map);const P=g.compiledExpressionMap;v&&P.set(y,v)}else g.props[y]=_[y];m.compiledMarkerInfos.push(g)})),l.set(u,m)}else s[u]={type:"cim-marker-transform-info",infos:d};break}case"animation-params":{const{params:d}=h,m=Ne(d);if(C(m)){const _=await Promise.all(m.map(g=>Qe(g,e)));p.set(u,{params:_,propertyIdToResourceId:new Map,key:u})}else{const _=He(m),g=await t.fetchResourceImmediate({type:"animation-info",resource:_});g!=null&&g.type==="sprite"&&(s[u]={dataRow:g.rect.y,dataColumn:g.rect.x})}break}default:s[u]=h}else s[u]=h}return new ee(n,s,a,i,o,c,l,p)}constructor(e,t,n,r,s,a,i,o){this.inputMeshParams=e,this._resolvedMeshParams=t,this._dynamicProperties=n,this._dynamicEffectProperties=r,this._dynamicPlacementProperties=s,this._dynamicAsyncProperties=a,this._dynamicTransformProperties=i,this._dynamicAsyncAnimations=o,this.evaluator=c=>c,this._arcadeDependencies=new Set;for(const c of this._expressions())Le(this._arcadeDependencies,c)}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size||this._dynamicAsyncAnimations.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(e,t,n){for(const r of this._dynamicAsyncProperties.values()){const s=Ae(r.rasterizationParam.resource);r.rasterizationParam.resource.type==="animated"&&r.rasterizationParam.resource.randomizeStartTime&&(s.primitiveName="__RESERVED__PRIMITIVE__NAME__",s.startGroup=Je(t.getObjectId()||0));for(const{primitiveName:i,propertyName:o,computed:c,defaultValue:l,valueExpressionInfo:p}of r.compiledOverrides)try{const u=r.rasterizationParam.resource.type==="animated"?s.primitiveName:i;Pt(s,u,o,c,t,n,l)}catch(u){Tt().errorOnce(new Se("invalid-arcade-expression","Encountered an error when evaluating the arcade expression",{error:u,valueExpressionInfo:p}))}const a=e.enqueueRequest({type:"cim-rasterization-info",resource:s});r.objectIdToResourceId.set(t.getObjectId(),a)}for(const r of this._dynamicAsyncAnimations.values()){const s=r.params.map(o=>Ue(o,t,n)).map(Ke).map(o=>o.simplify()),a=et(s),i=e.enqueueRequest({type:"animation-info",resource:a});r.propertyIdToResourceId.set(t.getObjectId()+"."+r.key,i)}}evaluateMeshParams(e,t,n){for(const[r,s]of this._dynamicProperties.entries())this._resolvedMeshParams[r]=s.computed.readWithDefault(t,n,s.defaultValue);for(const[r,s]of this._dynamicPlacementProperties.entries())for(const{computed:a,defaultValue:i,propertyName:o}of s.compiledOverrides){const c=a.readWithDefault(t,n,i);s.placementInfo.placement[o]=c,this._resolvedMeshParams[r]=s.placementInfo.placement}for(const[r,s]of this._dynamicEffectProperties.entries())for(const a of s.effects){for(const{computed:i,defaultValue:o,propertyName:c}of a.compiledOverrides){const l=i.readWithDefault(t,n,o);a.effect[c]=l}this._resolvedMeshParams[r]=s.effects.map(i=>i.effect)}for(const[r,s]of this._dynamicTransformProperties.entries()){const a={type:"cim-marker-transform-info",infos:[]};for(const i of s.compiledMarkerInfos){const o={...i.props};if(i.compiledExpressionMap)for(const[c,l]of i.compiledExpressionMap){const p=l.computed.readWithDefault(t,n,l.defaultValue);o[c]=typeof p=="number"||typeof p=="boolean"?p:l.defaultValue}a.infos.push(o)}this._resolvedMeshParams[r]=a}for(const[r,s]of this._dynamicAsyncProperties.entries()){const a=s.objectIdToResourceId.get(t.getObjectId());if(a==null)continue;const i=e.getResource(a);this._resolvedMeshParams[r]=i}for(const[r,s]of this._dynamicAsyncAnimations.entries()){const a=s.propertyIdToResourceId.get(t.getObjectId()+"."+r);if(a==null)continue;const i=e.getResource(a);this._resolvedMeshParams[r]={dataRow:i.rect.y,dataColumn:i.rect.x}}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}hasArcadeDependency(e){return this._arcadeDependencies.has(e)}*_expressions(){for(const e of this._dynamicProperties.values())yield e.computed;for(const e of this._dynamicEffectProperties.values())for(const t of e.effects)for(const n of t.compiledOverrides)yield n.computed;for(const e of this._dynamicPlacementProperties.values())for(const t of e.compiledOverrides)yield t.computed;for(const e of this._dynamicAsyncProperties.values())for(const t of e.compiledOverrides)yield t.computed;for(const e of this._dynamicTransformProperties.values())for(const t of e.compiledMarkerInfos)if(t.compiledExpressionMap!=null)for(const n of t.compiledExpressionMap.values())yield n.computed;for(const e of this._dynamicAsyncAnimations.values())for(const t of e.params)yield*tt(t)}}class Ut{async createMeshWriter(e,t,n,r,s){const a=this._getMeshWriter(r.techniqueType),i=await ee.create(e,t,r.inputParams,s),o=new a(r.id,i,r.optionalAttributes,n);return await o.loadDependencies(),o}_getMeshWriter(e){switch(e){case x.Fill:return pt;case x.DotDensity:return ft;case x.ComplexFill:return dt;case x.PatternFill:return mt;case x.GradientFill:return ut;case x.OutlineFill:return ht;case x.PatternOutlineFill:return lt;case x.ComplexOutlineFill:return ct;case x.Marker:return ot;case x.PieChart:return nt;case x.Text:return ye;case x.Line:return at;case x.TexturedLine:return it;case x.GradientStroke:return rt;case x.Heatmap:return st;case x.Label:return kt;case x.AnimatedMarker:return bt;case x.AnimatedMarkerShift:return It;case x.AnimatedFill:return $t;case x.AnimatedLine:return Lt;default:throw new Error("Internal Error: Mesh writer not in the registry")}}}export{Rt as r,Ut as y};
